<!DOCTYPE HTML>
<html>
<meta charset="utf-8">
<title>Data Lab Project</title>
<script src="https://d3js.org/d3.v4.min.js"> </script>
<head>
	<link rel="stylesheet" type="text/css" href="static/css/style.css">
</head>

<div id="tooltip" class="hidden">
	<p><strong>Path Information</strong></p>
	<p><span id="value">100</span>%</p>
</div>

<div class="dashboard">
	<div class="header">
		<p> Enter the values in the fields below!</p>
		<form>
			Start Hour = <input id="startHour" type="text" name="startHour" value=0>
			End Hour = <input id="endHour" type="text" name="endHour" value=23>
			Weekday is = <input id="Weekday" type="text" name="Weekday" value=0>
			Building is = <input id="Building" type="text" name="Building" value="Enter Building">
			<input name="update" type="Button" value="Update!" onclick="updateData()">
		</form>
	</div>
	<div class="body">
		<div class="sidebar">This is the sidebar</div>
		<div class="geoplot">
			<svg  id="campussvg" width="600px" height="620px" x="0" y="0">
  				<image xlink:href="static/images/campus_map3.png" x="0" y="0" height="620px" width="600px"/>
  				<defs>
				    <marker id="Triangle" viewBox="0 0 20 20" refX="10" refY="10"
				        markerWidth="15" markerHeight="15" orient="auto" markerUnits="userSpaceOnUse" fill="green" opacity=".7">
				      	<path d="M 0 0 L 20 10 L 0 20 z" />
				    </marker>
				</defs>
  				<line id= "pathLine" class="hidden" x1="0" x2="100" y1="0" y2="0" stroke-width="10" stroke="black" marker-end="url(#Triangle)"/>
  			</svg>
		</div>
		<div class="plots">
			<div id="plot1" class="plot1"></div>
			<div id = "plot2" class="plot2">
				<div id="tooltip" class="hidden">
					<p><strong>Path Information</strong></p>
					<p><span id="value">100</span>%</p>
				</div>
			</div>
		</div>
	</div>
</div>

<script type="text/javascript">

/** INSERT BUILDING TABLE **/

	var building_table = d3.map();
	function lookupTable(data) {
		data.forEach(function(d){
			building_table = building_table.set(d.building_names, [d.longitude, d.latitude]);
		});
	}

	d3.json("/api/building_coords", lookupTable);

	var latitudeScale = d3.scaleLinear().range([0, 620]);//h]);
  	var longitudeScale = d3.scaleLinear().range([0, 600]);//w]);

	function pathBarChartBasics() {

		var margin = {top: 10, right: 10, bottom: 10, left: 30},
		width = 300,
	   	height = 300,
		barPadding = 1
		;
		
		return {
			margin : margin, 
			width : width, 
			height : height,  
			barPadding : barPadding
		}			
		;
	}

	function pathBarChart(data){

		var basics = pathBarChartBasics();
	
		var margin = basics.margin,
			w = basics.width,
		   	h = basics.height,
			barPadding = basics.barPadding
			;
		//Width and height
		//var w = 500;
		//var h = 300;
		//var margin = { left: 30, top: 30, right: 30, bottom: 30 };
		//var barPadding = .05;
		//var yColumn = "count";
		//var xColumn = "end";

		//Inner SVG dimensions
		var innerWidth  = w  - margin.left - margin.right;
		var innerHeight = h - margin.top  - margin.bottom;

		//var initialized = 0;

		// var xScale = d3.scaleBand()
		// 				//.domain(d3.range(dataset.length))
		// 				.range([0, innerWidth], barPadding)
		// 				.padding(barPadding);

		var xScale = d3.scaleLinear()
						//.domain([0, d3.max(dataset)])
						.range([0, innerWidth]);

		var cScale = d3.scaleLinear()
						.range([50, 250]);

		var lineScale = d3.scaleLinear().range([2, 10]);
		
		//Create SVG element
		var svg = d3.select("#plot2")
					.append("svg")
					.attr("width", w)
					.attr("height", h);

		//Appending group to svg
		var g = svg.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		var g2 = svg.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
		//Adding x-axis to new group and translating axis
		var xAxisG = g.append("g")
			.attr("transform", "translate(0," + (innerHeight - margin.bottom) + ")");

		//Adding y-axis to new group but setting no attributes
		//var yAxisG = g.append("g");

		//x and y axis
		var xAxis = d3.axisBottom(xScale);
		// var yAxis = d3.axisLeft(yScale);

		//function renderBarChart(data){

		console.log("RENDERING BAR CHART!");
		//initialized = 1;

		console.log(data);
		xScale.domain([0, d3.max(data, function (d){ return d['count']; })]);
		//xScale.domain(data.map( function (d){ return d[xColumn]; }));
		cScale.domain([d3.min(data, function (d){ return d['count']; }), d3.max(data, function (d){ return d['count']; })]);
		lineScale.domain([d3.min(data, function (d){ return d['count']; }), d3.max(data, function (d){ return d['count']; })]);
		//xAxisG.call(xAxis);
		// yAxisG.call(yAxis);

		var bars = g.selectAll("rect")
		   .data(data)
		   .enter()
		   .append("rect")
		   .attr("x", function(d) {
		   		return 0;//xScale(d[xColumn]);
		   })
		   .attr("y", function(d, i) {
		   		return i * 25;//yScale(d[yColumn]);
		   })
		   .attr("height", "24px")
		   .attr("width", function(d) {
		   		return xScale(d['count']);
		   })
		   .attr("fill", function(d) {
		   		//console.log(cScale(d[yColumn]));
				return "rgb(0, 0, " + (Math.round(cScale(d['count']))) + ")";
		   })
		   .on("mouseover", function(d) {

		   		console.log(latitudeScale(43.01));
				//Get this bar's x/y values, then augment for the tooltip
				//var xPosition = parseFloat(d3.select(this).attr("x")) + xScale.bandwidth() / 2;
				//var yPosition = parseFloat(d3.select(this).attr("y")) / 2 + h / 2;

				//Update the tooltip position and value
				d3.select("#pathLine")
					.attr("x1", longitudeScale(building_table.get(d['start'])[0]) - 4)
					.attr("x2", longitudeScale(building_table.get(d['end'])[0]) - 4)
					.attr("y1", latitudeScale(building_table.get(d['start'])[1]) + 4)
					.attr("y2", latitudeScale(building_table.get(d['end'])[1]) + 4)
					.attr("stroke-width", lineScale(d['count']))
					.attr("class", "show");
					//.style("top", yPosition + "px");						
					//.select("#value")
					//.text("There are "+d.count+" people going to "+d.end);
		   
				//Show the tooltip
				//d3.select("#pathLine").class("hidden", false);

		   })
		   .on("mouseout", function() {
		   
				//Hide the tooltip
				d3.select("#pathLine").classed("hidden", true);
				
		   });;

		g.selectAll("text")
		    .data(data)
   			.enter().append("svg:text")
     		.attr("x", 2)
     		.attr("y", function(d, i) { return (i * 25) + 12; })
     		.attr("fill", "#7FFF00")
     		.attr("font-size", "10px")
		    .text(function(d){ return d['start']; });

		var endLabels = g2.selectAll("text")
		    .data(data)
   			.enter().append("svg:text")
     		.attr("x", function(d) {
		   		return xScale(d['count']) - 2; })
     		.attr("y", function(d, i) { return (i * 25) + 12; })
     		.attr("fill", "red")
     		.attr("font-size", "10px")
		    //.attr("dx", -3) // padding-right
		    //.attr("dy", ".35em") // vertical-align: middle
		    .attr("text-anchor", "end") // text-align: right
		    //.attr("stroke", "white")
		    .text(function(d){ return d['end']; });

		xAxisG.call(xAxis);

	}
	
	function type(data) {
		console.log("AT TYPE!");
		data[0]["Buildings"].forEach(function(d){
			d.Count = +d.Count;
		});
		data[0]["Time"].forEach(function(d){
			d.Count = +d.Count;
		});
		data[0]["Paths"].forEach(function(d){
			d.count = +d.count;
		});
		//console.log(data);
		pathBarChart(data[0]["Paths"]);
		hourScatterPlot(data[0]["Time"]);
		heatMap(data[0]["Buildings"]);
	}
	function update(data){
		console.log("UPDATING NOW!");
		data.forEach(function(d){
			d.count = +d.count;
		});

		yScale.domain([0, d3.max(data, function (d){ return d[yColumn]; })]);
		xScale.domain(data.map( function (d){ return d[xColumn]; }));
		cScale.domain([d3.min(data, function (d){ return d[yColumn]; }), d3.max(data, function (d){ return d[yColumn]; })]);

		xAxisG.call(xAxis);
		yAxisG.call(yAxis);

		g.selectAll("rect")
		   .data(data)
		   .transition()
		   .attr("x", function(d) {
		   		return xScale(d[xColumn]);
		   })
		   .attr("y", function(d) {
		   		return yScale(d[yColumn]);
		   })
		   .attr("width", xScale.bandwidth())
		   .attr("height", function(d) {
		   		return innerHeight - yScale(d[yColumn]);
		   })
		   .attr("fill", function(d) {
		   		console.log(cScale(d[yColumn]));
				return "rgb(0, 0, " + (Math.round(cScale(d[yColumn]))) + ")";
		   });

	}

	// function printData(data){
	// 	console.log("MADE IT HERE! "+ data);
	// 	console.log("TIME: "+data[0]['Time']);
	// 	data[0]['Time'].forEach(function(d){
	// 		console.log(d['Hour'], d['Count']);
	// 	});
	// }

	function updateData(){

			var startHour = d3.select("#startHour").property("value");
			var endHour = 1 + parseInt(d3.select("#endHour").property("value"));
			console.log("startHour: " + startHour)
			console.log("endHour: " + endHour)
			console.log("newRange: " + d3.range(startHour, endHour))
			var Hour = d3.range(startHour, endHour)
			var Weekday = d3.select("#Weekday").property("value");
			var Building = d3.select("#Building").property("value");
			console.log("HOUR IS: "+Hour.toString()+" WEEKDAY IS: "+Weekday+" BUILDING IS: "+Building);

			//d3.json("/api/all?Hour="+Hour.toString()+"&Weekday="+Weekday+"&Building="+Building, printData);


			//if (initialized==0){
			d3.json("/api/all?Hour="+Hour.toString()+"&Weekday="+Weekday, type);//+"&Building="+Building, type);
				//d3.json("/api/wifi?Hour="+Hour.toString()+"&Weekday="+Weekday+"&Building="+Building, type);
				//d3.json("/api/connections?Hour="+Hour.toString()+"&Weekday="+Weekday+"&Building="+Building, type2);
			//}
			//else{
			//	d3.json("/api/all?Hour="+Hour.toString()+"&Weekday="+Weekday+"&Building="+Building, type);
				//d3.json("/api/wifi?Hour="+Hour.toString()+"&Weekday="+Weekday+"&Building="+Building, update);
				//d3.json("/api/connections?Hour="+Hour.toString()+"&Weekday="+Weekday+"&Building="+Building, update2);
			//}
	}    
	function scatterPlotBasics(){
		var margin = {top: 30, right: 30, bottom: 30, left: 50},
			width = 300,
		   	height = 300,
			circleRadius = 5
			;
		
		return {
			margin : margin, 
			width : width, 
			height : height,
			circleRadius : circleRadius 
		};			
		
	}

	function hourScatterPlot(data){

		var basics = scatterPlotBasics();
		var margin = basics.margin,
			w = basics.width,
		   	h = basics.height,
		   	circleRadius = basics.circleRadius
			;
      	//Width and height
      	// var w2 = 300;
      	// var h2 = 300;
      	// var circleRadius = 5;
      	// var margin2 = { left: 50, top: 30, right: 30, bottom: 30 };
      	// var xColumn2 = 'Hour';
      	// var yColumn2 = 'Count';

      	//Inner SVG dimensions
      	var innerWidth  = w - margin.left - margin.right;
      	var innerHeight = h - margin.top  - margin.bottom;

      	var svg = d3.select("#plot1").append("svg")
        	.attr("width", w)
        	.attr("height", h);

      	var xScale = d3.scaleBand().range([0, innerWidth]);
      	var yScale = d3.scaleLinear().range([innerHeight, 0]);

      	//Appending group to svg
      	var g = svg.append("g")
      		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      	//Adding x-axis to new group and translating axis
      	var xAxisG = g.append("g")
                    .attr("transform", "translate(0," + innerHeight + ")");

      	//Adding y-axis to new group but setting no attributes
      	var yAxisG = g.append("g");

      	//x and y axis
      	var xAxis = d3.axisBottom(xScale);
      	var yAxis = d3.axisLeft(yScale);

      	console.log("HOW ARE YOU GETTING HERE!?");
      	// text label for the y axis
	    g.append("text")
	            .attr("transform", "rotate(-90)")
	            .attr("y", 0 - margin.left)
	            .attr("x",0 - (innerHeight / 2))
	            .attr("dy", "1em")
	            .style("text-anchor", "middle")
	            .text("Count");

	    // text label for the x axis
	    svg.append("text")             
	          .attr("transform",
	                "translate(" + (w/2) + " ," + 
	                               (innerHeight + margin.top + 30) + ")")
	          .style("text-anchor", "middle")
	          .text("Hour");

        xScale.domain(data.map( function (d){ return d['Hour']; }));
        yScale.domain([0, d3.max(data, function (d){ return d['Count']; })]);

        xAxisG.call(xAxis);
        yAxisG.call(yAxis);

        var circles = g.selectAll("circle")
          .data(data)
          .enter()
          .append("circle")
          .attr("class", "circle")
          .attr("r", circleRadius);

        circles
          .attr("cx", function (d){ 
            console.log("d[xColumn]: " + d['Hour']);
            console.log("xScale(d[xColumn]): " + xScale(d["Hour"]));
            return xScale(d["Hour"]) + margin.right - circleRadius; })
          .attr("cy", function (d){ return yScale(d['Count']); });
        
        circles.exit().remove();

      
	}
      // function type2(d){
      //   console.log("TYPE: " + d.Count);
      //   d.Count = +d.Count;
      //   //d.Hour = +d.Hour;
      //   return d;
      // }
 //      function type2(data) {
	// 	//console.log(data);
	// 	data.forEach(function(d){
	// 		d.Count = +d.Count;
	// 	});
	// 	render2(data);
	// }

      function update2(data){
		console.log("UPDATING CONNECTION TIME CHART NOW!");
		data.forEach(function(d){
			d.Count = +d.Count;
		});

		yScale2.domain([0, d3.max(data, function (d){ return d[yColumn2]; })]);
		xScale2.domain(data.map( function (d){ return d[xColumn2]; }));

		xAxisG2.call(xAxis2);
		yAxisG2.call(yAxis2);

		g2.selectAll("circle")
		   .data(data)
		   .transition()
		   .attr("cx", function (d){return xScale2(d[xColumn2]) + margin2.right - circleRadius; })
          .attr("cy", function (d){ return yScale2(d[yColumn2]); });

	}

	/* HEAT MAP */
	function heatMapBasics(){
		var coords = {lat1: 43.1451636, lat2: 43.1297806, long1: -70.940935, long2: -70.9262369},
			width = 600,
		   	height = 620,
			circleRadius = 5
			;
		
		return {
			coords : coords,
			width : width, 
			height : height,
			circleRadius : circleRadius,

		};	
	}

	function heatMap(data){

		var basics = heatMapBasics();

		var coords = basics.coords,
			w = basics.width,
		   	h = basics.height,
		   	circleRadius = basics.circleRadius
			;

		// var latitudeScale = d3.scaleLinear().range([0, h]);
  // 		var longitudeScale = d3.scaleLinear().range([0, w]);
  		var circleScale = d3.scaleSqrt().range([3,12]);

  		latitudeScale.domain([coords.lat1, coords.lat2]);
  		longitudeScale.domain([coords.long1, coords.long2]);

  		var svg = d3.select("#campussvg");

  		// svg.append("text")             
    //       .attr("transform",
    //             "translate(" + (w/2) + " ," + 
    //                            (h - 30) + ")")
    //       .style("text-anchor", "middle")
    //       .text("Hour");

        circleScale.domain([d3.min(data, function (d){ return d['Count']; }), d3.max(data, function (d){ return d['Count']; })]);

		var circles = svg.selectAll("circle")
			.data(data)
			.enter()
			.append('circle')
				.attr("class", "circle")
		  		.attr("r", function(d){
		  			return circleScale(d['Count']);
		  		})
		  		.attr("cx", function(d) {
		  			console.log(d["Building"])
		  			return longitudeScale(building_table.get(d['Building'])[0]) - 4;
		  		})
		  		.attr("cy", function(d){
		  			return latitudeScale(building_table.get(d['Building'])[1]) + 4;
		  		})
		  		.on("mouseover", function(d){
		  			console.log(d['Building'], d['Count']);
		  		});
		// var pathLine = svg.selectAll("line")
		// 				.append("line")
		// 				.attr("x1", 0)
		// 				.attr("y1", 0)
		// 				.attr("x2", 100)
		// 				.attr("y2", 0);
	}
	// function drawPaths(data) {

	// }
      // var the_data = [{"Hour":0,"Count":3781},{"Hour":1,"Count":2949},{"Hour":2,"Count":2646},{"Hour":3,"Count":2055},{"Hour":4,"Count":909}];
      // console.log(the_data);
      // //data = type(data);
      // render(the_data);
   

    </script>

</body>

</html>