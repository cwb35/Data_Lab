<!DOCTYPE HTML>
<html>
<meta charset="utf-8">
<title>Data Lab Project</title>
<script src="https://d3js.org/d3.v4.min.js"> </script>
<!-- <script src="static/JS/d3-tip.js"></script> -->
<!-- <script src="static/JS/d3.legend.js"></script> -->
<head>
	<link rel="stylesheet" type="text/css" href="static/css/style.css">
</head>

<div id="tooltip" class="hidden">
	<p><strong>Path Information</strong></p>
	<p><span id="value">100</span>%</p>
</div>

<div class="dashboard">
	<div class="header">
		<p> Enter the values in the fields below!</p>
		<form>
			Start Hour = <input id="startHour" type="text" name="startHour" value=0>
			End Hour = <input id="endHour" type="text" name="endHour" value=8>
			Weekday is = <input id="Weekday" type="text" name="Weekday" value=0>
			Building is = <input id="Building" type="text" name="Building" value="Enter Building">
			<input name="update" type="Button" value="Update!" onclick="updateData()">
		</form>
	</div>
	<div class="body">
		<div class="sidebar">This is the sidebar</div>
		<div class="geoplot">
			<svg  id="campussvg" width="600px" height="620px" x="0" y="0">
  				<image xlink:href="static/images/campus_map3.png" x="0" y="0" height="620px" width="600px"/>
<!--   				<defs>
				    <marker id="Triangle" viewBox="0 0 7 7" refX="10" refY="10"
				        markerWidth="6" markerHeight="6" orient="auto" fill="black" opacity=".7">
				      	<path d="M 0 0 L 6 3 L 0 6 z" />
				    </marker>
				</defs> -->
  				<line id= "pathLine" class="hidden" x1="0" x2="100" y1="0" y2="0" stroke-width="3" stroke="black"/>
  			</svg>
		</div>
		<div class="plots">
			<div id="plot1" class="plot1"></div>
			<div id = "plot2" class="plot2">
				<div id="tooltip" class="hidden">
					<p><strong>Path Information</strong></p>
					<p><span id="value">100</span>%</p>
				</div>
			</div>
		</div>
	</div>
</div>

<script type="text/javascript">

/** INSERT BUILDING TABLE **/
	
	var initialized = 0;

	var building_table = d3.map();
	function lookupTable(data) {
		//console.log(data);
		data.forEach(function(d){
			building_table = building_table.set(d.building_names, [d.longitude, d.latitude, d.building_type]);
		});
	}

	d3.json("/api/building_coords", lookupTable);

	var latitudeScale = d3.scaleLinear().range([0, 620]);//h]);
  	var longitudeScale = d3.scaleLinear().range([0, 600]);//w]);

  	var lineData = [];

  	var origData = [];

  	var selectedBuilding = "None";

	function pathBarChartBasics() {

		var margin = {top: 30, right: 10, bottom: 10, left: 30},
		width = 300,
	   	height = 300,
		barPadding = 1
		;
		
		return {
			margin : margin, 
			width : width, 
			height : height,  
			barPadding : barPadding
		}			
		;
	}

	function pathBarChart(data){

		var basics = pathBarChartBasics();
	
		var margin = basics.margin,
			w = basics.width,
		   	h = basics.height,
			barPadding = basics.barPadding
			;
		//Width and height
		//var w = 500;
		//var h = 300;
		//var margin = { left: 30, top: 30, right: 30, bottom: 30 };
		//var barPadding = .05;
		//var yColumn = "count";
		//var xColumn = "end";

		//Inner SVG dimensions
		var innerWidth  = w  - margin.left - margin.right;
		var innerHeight = h - margin.top  - margin.bottom;

		//var initialized = 0;

		// var xScale = d3.scaleBand()
		// 				//.domain(d3.range(dataset.length))
		// 				.range([0, innerWidth], barPadding)
		// 				.padding(barPadding);

		var xScale = d3.scaleLinear()
						//.domain([0, d3.max(dataset)])
						.range([0, innerWidth]);

		var cScale = d3.scaleLinear()
						.range([50, 250]);

		var lineScale = d3.scaleLinear().range([2, 10]);
		
		//Create SVG element
		var svg = d3.select("#plot2")
					.append("svg")
					.attr("width", w)
					.attr("height", h);

		//Appending group to svg
		var g = svg.append("g")
			.attr("id", "pathGroup1")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		var g2 = svg.append("g")
			.attr("id", "pathGroup2")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
		//Adding x-axis to new group and translating axis
		var xAxisG = g.append("g")
			.attr("id", "pathChartXAxis")
			.attr("transform", "translate(0," + (innerHeight - margin.bottom) + ")");

		//Adding y-axis to new group but setting no attributes
		//var yAxisG = g.append("g");

		//x and y axis
		var xAxis = d3.axisBottom(xScale);
		// var yAxis = d3.axisLeft(yScale);

		//function renderBarChart(data){

		console.log("RENDERING BAR CHART!");
		//initialized = 1;

		console.log(data);
		xScale.domain([0, d3.max(data, function (d){ return d['count']; })]);
		//xScale.domain(data.map( function (d){ return d[xColumn]; }));
		cScale.domain([d3.min(data, function (d){ return d['count']; }), d3.max(data, function (d){ return d['count']; })]);
		lineScale.domain([d3.min(data, function (d){ return d['count']; }), d3.max(data, function (d){ return d['count']; })]);
		//xAxisG.call(xAxis);
		// yAxisG.call(yAxis);

		var bars = g.selectAll("rect")
		   .data(data)
		   .enter()
		   .append("rect")
		   .attr("class", "pathRect")
		   .attr("x", function(d) {
		   		return 0;//xScale(d[xColumn]);
		   })
		   .attr("y", function(d, i) {
		   		return i * 25;//yScale(d[yColumn]);
		   })
		   .attr("height", "24px")
		   .attr("width", function(d) {
		   		return xScale(d['count']);
		   })
		   .attr("fill", function(d) {
		   		//console.log(cScale(d[yColumn]));
				return "rgb(0, 0, " + (Math.round(cScale(d['count']))) + ")";
		   })
		   .on("mouseover", function(d) {

		   		//console.log(latitudeScale(43.01));
				//Get this bar's x/y values, then augment for the tooltip
				//var xPosition = parseFloat(d3.select(this).attr("x")) + xScale.bandwidth() / 2;
				//var yPosition = parseFloat(d3.select(this).attr("y")) / 2 + h / 2;

				//Update the tooltip position and value
				d3.select("#pathLine")
					.attr("x1", longitudeScale(building_table.get(d['start'])[0]) - 4)
					.attr("x2", longitudeScale(building_table.get(d['end'])[0]) - 4)
					.attr("y1", latitudeScale(building_table.get(d['start'])[1]) + 4)
					.attr("y2", latitudeScale(building_table.get(d['end'])[1]) + 4)
					//.attr("stroke-width", lineScale(d['count']))
					.attr("class", "show");
					//.style("top", yPosition + "px");						
					//.select("#value")
					//.text("There are "+d.count+" people going to "+d.end);
		   		if (selectedBuilding == "None"){
			   		d3.selectAll(".circle")
			   			.attr("class", "uncolor");
			   	}
		   		console.log("#"+d['start'].replace(/\s/g, ""));
		   		d3.select("#"+d['start'].replace(/\s/g, ""))
		   			.attr("class", "selected");
		   		d3.select("#"+d['end'].replace(/\s/g, ""))
		   			.attr("class", "selected");
		   		// d3.selectAll(".circle")
		   		// 	.attr("class", "uncolor");

		   		// console.log("#"+d['start'].replace(/\s/g, ""));
		   		// d3.select("#"+d['start'].replace(/\s/g, ""))
		   		// 	.attr("class", "selected");
		   		// d3.select("#"+d['end'].replace(/\s/g, ""))
		   		// 	.attr("class", "selected");
				//Show the tooltip
				//d3.select("#pathLine").class("hidden", false);

		   })
		   .on("mouseout", function(d) {
		   
				//Hide the tooltip
				d3.select("#pathLine").classed("hidden", true);
				if (selectedBuilding == "None"){
					d3.selectAll(".uncolor")
			   			.attr("class", "circle");
			   		d3.selectAll(".selected")
			   			.attr("class", "circle");
		   		} else {
		   			d3.select("#"+d['end'].replace(/\s/g, ""))
		   				.attr("class", "circle");
		   		}
				// d3.selectAll(".uncolor")
		  //  			.attr("class", "circle");
		  //  		d3.selectAll(".selected")
		  //  			.attr("class", "circle");
				
		   });;

		g.selectAll("text")
		    .data(data)
   			.enter().append("svg:text")
     		.attr("x", 2)
     		.attr("y", function(d, i) { return (i * 25) + 12; })
     		.attr("class", "startLabel")
     		//.attr("fill", "#7FFF00")
     		//.attr("font-size", "10px")
		    .text(function(d){ return d['start']; });

		var endLabels = g2.selectAll("text")
		    .data(data)
   			.enter().append("svg:text")
     		//.attr("x", function(d) {
		   	//	return xScale(d['count']) - 2; })
		   	.attr("class", "endLabel")
		   	.attr("x", innerWidth)
     		.attr("y", function(d, i) { return (i * 25) + 12; })
     		//.attr("fill", "red")
     		//.attr("font-size", "10px")
		    //.attr("dx", -3) // padding-right
		    //.attr("dy", ".35em") // vertical-align: middle
		    .attr("text-anchor", "end") // text-align: right
		    //.attr("stroke", "white")
		    .text(function(d){ return d['end']; });

		xAxisG.call(xAxis);

	}
	
	function updatePathChart(data) {

		console.log(data);
		var basics = pathBarChartBasics();
	
		var margin = basics.margin,
			w = basics.width,
		   	h = basics.height,
			barPadding = basics.barPadding
			;

		//Inner SVG dimensions
		var innerWidth  = w  - margin.left - margin.right;
		var innerHeight = h - margin.top  - margin.bottom;

		var xScale = d3.scaleLinear()
						//.domain([0, d3.max(dataset)])
						.range([0, innerWidth]);

		var cScale = d3.scaleLinear()
						.range([50, 250]);

		var lineScale = d3.scaleLinear().range([2, 10]);

		var g = d3.select("#pathGroup1");

		var g2 = d3.select("#pathGroup2");
		
		var xAxisG = d3.select('#pathChartXAxis');
		
		var xAxis = d3.axisBottom(xScale);
		// var yAxis = d3.axisLeft(yScale);

		//function renderBarChart(data){

		console.log("g2:");
		console.log(g2);
		//initialized = 1;

		console.log(data);
		xScale.domain([0, d3.max(data, function (d){ return d['count']; })]);
		//xScale.domain(data.map( function (d){ return d[xColumn]; }));
		cScale.domain([d3.min(data, function (d){ return d['count']; }), d3.max(data, function (d){ return d['count']; })]);
		lineScale.domain([d3.min(data, function (d){ return d['count']; }), d3.max(data, function (d){ return d['count']; })]);
		
		var svg = d3.select("#plot2 svg").transition();

		var bars = g.selectAll("rect")
		   .data(data)
		   .on("mouseover", function(d) {

		   		console.log("HERE!");
				//Update the tooltip position and value
				d3.select("#pathLine")
					.attr("x1", longitudeScale(building_table.get(d['start'])[0]) - 4)
					.attr("x2", longitudeScale(building_table.get(d['end'])[0]) - 4)
					.attr("y1", latitudeScale(building_table.get(d['start'])[1]) + 4)
					.attr("y2", latitudeScale(building_table.get(d['end'])[1]) + 4)
					//.attr("stroke-width", lineScale(d['count']))
					.attr("class", "show");
		   		
		   		if (selectedBuilding == "None"){
			   		d3.selectAll(".circle")
			   			.attr("class", "uncolor");
			   		d3.select("#"+d['start'].replace(/\s/g, ""))
			   			.attr("class", "selected");
			   		d3.select("#"+d['end'].replace(/\s/g, ""))
			   			.attr("class", "selected");
			   	}
			   	else if(selectedBuilding == d['start']){
			   		console.log("#"+d['start'].replace(/\s/g, ""));
			   		d3.select("#"+d['start'].replace(/\s/g, ""))
			   			.attr("class", "selected");
			   		d3.select("#"+d['end'].replace(/\s/g, ""))
			   			.attr("class", "selected");
		   		}

				//Show the tooltip
				//d3.select("#pathLine").class("hidden", false);

		   })
		   .on("mouseout", function(d) {
		   
				//Hide the tooltip
				d3.select("#pathLine").classed("hidden", true);
				if (selectedBuilding == "None"){
					d3.selectAll(".uncolor")
			   			.attr("class", "circle");
			   		d3.selectAll(".selected")
			   			.attr("class", "circle");
		   		} 
		   		else if(selectedBuilding == d['start']) {
		   			d3.select("#"+d['end'].replace(/\s/g, ""))
		   				.attr("class", "circle");
		   		}
				
		   });

	    //bars.select(".bar").transition()
		svg.selectAll('rect').duration(300)
		  	.attr("width", function(d) { return xScale(d['count']);})
		  	.attr("opacity",1);
		console.log("TEXT DATA!");
		console.log(data);
		g.selectAll(".startLabel")
		    .data(data)
		    .text(function(d){ 
		    	console.log("STARTING TEXT:");
		    	console.log(d['start']);
		    	return d['start']; }
		    );
		g.transition().duration(400);

		var endLabels = g2.selectAll("text")
		    .data(data)
   			// //.enter().append("svg:text")
   			// .attr("x", innerWidth)
     	// 	//.attr("x", function(d) {
		   	// //	return xScale(d['count']) - 2; })
		    .text(function(d){ return d['end']; });

		xAxisG.call(xAxis);

	}



	function type(data) {
		console.log("AT TYPE!");
		data[0]["Buildings"].forEach(function(d){
			d.Count = +d.Count;
		});
		data[0]["Time"].forEach(function(d){
			d.Count = +d.Count;
		});
		data[0]["Paths"].forEach(function(d){
			d.count = +d.count;
		});
		origData = data;
		//console.log(data);
		pathBarChart(data[0]["Paths"]);
		hourScatterPlot(data[0]["Time"]);
		heatMap(data[0]["Buildings"]);
	}
	function update(data){
		console.log("UPDATING NOW!");
		data.forEach(function(d){
			d.count = +d.count;
		});

		yScale.domain([0, d3.max(data, function (d){ return d[yColumn]; })]);
		xScale.domain(data.map( function (d){ return d[xColumn]; }));
		cScale.domain([d3.min(data, function (d){ return d[yColumn]; }), d3.max(data, function (d){ return d[yColumn]; })]);

		xAxisG.call(xAxis);
		yAxisG.call(yAxis);

		g.selectAll("rect")
		   .data(data)
		   .transition()
		   .attr("x", function(d) {
		   		return xScale(d[xColumn]);
		   })
		   .attr("y", function(d) {
		   		return yScale(d[yColumn]);
		   })
		   .attr("width", xScale.bandwidth())
		   .attr("height", function(d) {
		   		return innerHeight - yScale(d[yColumn]);
		   })
		   .attr("fill", function(d) {
		   		console.log(cScale(d[yColumn]));
				return "rgb(0, 0, " + (Math.round(cScale(d[yColumn]))) + ")";
		   });

	}
	function updateCharts(data) {
		console.log("Update chart data:");
		console.log(data);
		updateLineChart(data[0]['Time']);
		updatePathChart(data[0]['Paths']);
		updateHeatMap(data[0]['Buildings']);
	}

	function newQuery(data) {
		origData = data;

		//Makes sure nothing is selected when query runs
		if (selectedBuilding != "None"){

   			d3.selectAll(".uncolor")
	   			.attr("class", "circle");
	   		d3.selectAll(".selected")
	   			.attr("class", "circle");
	   		selectedBuilding = "None";
		}
		updateCharts(data);
	}

	// function printData(data){
	// 	console.log("MADE IT HERE! "+ data);
	// 	console.log("TIME: "+data[0]['Time']);
	// 	data[0]['Time'].forEach(function(d){
	// 		console.log(d['Hour'], d['Count']);
	// 	});
	// }

	function updateData(){

			var startHour = d3.select("#startHour").property("value");
			var endHour = 1 + parseInt(d3.select("#endHour").property("value"));
			console.log("startHour: " + startHour)
			console.log("endHour: " + endHour)
			console.log("newRange: " + d3.range(startHour, endHour))
			var Hour = d3.range(startHour, endHour)
			var Weekday = d3.select("#Weekday").property("value");
			var Building = d3.select("#Building").property("value");
			console.log("HOUR IS: "+Hour.toString()+" WEEKDAY IS: "+Weekday+" BUILDING IS: "+Building);

			//d3.json("/api/all?Hour="+Hour.toString()+"&Weekday="+Weekday+"&Building="+Building, printData);

			if (initialized==0){
				initialized = 1;
				d3.json("/api/all?Hour="+Hour.toString()+"&Weekday="+Weekday, type);//+"&Building="+Building, type);
			} else {
				d3.json("/api/all?Hour="+Hour.toString()+"&Weekday="+Weekday, newQuery);//updateCharts);
			}
				//d3.json("/api/wifi?Hour="+Hour.toString()+"&Weekday="+Weekday+"&Building="+Building, type);
				//d3.json("/api/connections?Hour="+Hour.toString()+"&Weekday="+Weekday+"&Building="+Building, type2);
			//}
			//else{
			//	d3.json("/api/all?Hour="+Hour.toString()+"&Weekday="+Weekday+"&Building="+Building, type);
				//d3.json("/api/wifi?Hour="+Hour.toString()+"&Weekday="+Weekday+"&Building="+Building, update);
				//d3.json("/api/connections?Hour="+Hour.toString()+"&Weekday="+Weekday+"&Building="+Building, update2);
			//}
	}    
	function scatterPlotBasics(){
		var margin = {top: 30, right: 30, bottom: 30, left: 50},
			width = 300,
		   	height = 300,
			circleRadius = 5
			;
		
		return {
			margin : margin, 
			width : width, 
			height : height,
			circleRadius : circleRadius 
		};			
		
	}

	function hourScatterPlot(data){

		data.forEach(function(d){
			lineData.push(d);
		});
		var hourLookup = d3.map();
		data.forEach(function(d, i){
    		hourLookup = hourLookup.set(d.Hour, i);
			d.Count = +d.Count;
		});

		var basics = scatterPlotBasics();
		var margin = basics.margin,
			w = basics.width,
		   	h = basics.height,
		   	circleRadius = basics.circleRadius
			;

      	//Inner SVG dimensions
      	var innerWidth  = w - margin.left - margin.right;
      	var innerHeight = h - margin.top  - margin.bottom;

      	var svg = d3.select("#plot1").append("svg")
        	.attr("width", w)
        	.attr("height", h);

      	var xScale = d3.scaleLinear().rangeRound([0, innerWidth]);
      	var yScale = d3.scaleLinear().rangeRound([innerHeight, 0]);

      	var bisectHour = d3.bisector(function(d) { return d['Hour']; }).left;

      	//Appending group to svg
      	var g = svg.append("g")
      		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      	//Adding x-axis to new group and translating axis
      	var xAxisG = g.append("g")
      				.attr("id", "lineChartXAxis")
                    .attr("transform", "translate(0," + innerHeight + ")");

      	//Adding y-axis to new group but setting no attributes
      	var yAxisG = g.append("g")
      					.attr("id", "lineChartYAxis");

      	//x and y axis
      	var xAxis = d3.axisBottom(xScale);
      	var yAxis = d3.axisLeft(yScale);

      	console.log("HOW ARE YOU GETTING HERE!?");
      	// text label for the y axis
	    g.append("text")
	            .attr("transform", "rotate(-90)")
	            .attr("y", 0 - margin.left)
	            .attr("x",0 - (innerHeight / 2))
	            .attr("dy", "1em")
	            .style("text-anchor", "middle")
	            .text("Count");

	    // text label for the x axis
	    svg.append("text")             
	          .attr("transform",
	                "translate(" + (w/2) + " ," + 
	                               (innerHeight + margin.top + 30) + ")")
	          .style("text-anchor", "middle")
	          .text("Hour");

        //xScale.domain(data.map( function (d){ return d['Hour']; }));
        xScale.domain(d3.extent(data, function(d) { return d['Hour']; }));
        yScale.domain([0, d3.max(data, function (d){ return d['Count']; })]);

        xAxisG.call(xAxis);
        yAxisG.call(yAxis);

        //line
      	var line = d3.line()
		    .x(function(d) { return xScale(d['Hour']); })
		    .y(function(d) { return yScale(d['Count']); });

		var timeLine = g.append("path")
					      .datum(data)
					      .attr("id", "linePath")
					      .attr("fill", "none")
					      .attr("stroke", "steelblue")
					      .attr("stroke-linejoin", "round")
					      .attr("stroke-linecap", "round")
					      .attr("stroke-width", 1.5)
					      .attr("d", line);

		var focus = svg.append("g")
		      .attr("class", "focus")
		      .style("display", "none");

		focus.append("circle")
		      .attr("r", 4.5);

		focus.append("text")
		      .attr("x", 9)
		      .attr("dy", ".35em");

		svg.append("rect")
		      .attr("class", "overlay")
		      .attr("width", w)
		      .attr("height", h)
		      .on("mouseover", function() { focus.style("display", null); })
		      .on("mouseout", function() { focus.style("display", "none"); })
		      .on("mousemove", mousemove);

		function mousemove() {
		    var x0 = xScale.invert(d3.mouse(this)[0] - margin.left);
		    if (x0 < d3.min(data, function (d){ return d['Hour']; })) {
		    	x0 = d3.min(data, function (d){ return d['Hour']; });
		    }
		    if (x0 > d3.max(data, function (d){ return d['Hour']; })) {
		    	x0 = d3.max(data, function (d){ return d['Hour']; });
		    }
		    var i = hourLookup.get(Math.round(x0));
		    if (i<=0){
		    	d = data[0];
		    } else {
			    var d0 = data[i - 1];
			    console.log(d0)
			    var d1 = data[i],
			        d = x0 - d0['Hour'] > d1['Hour'] - x0 ? d1 : d0;
			}
		    focus.attr("transform", "translate(" + (margin.left + xScale(d['Hour'])) + "," + (margin.top + yScale(d['Count'])) + ")");
		    focus.select("text").text(d['Count']);
			
		}
		// function mousemove() {
		//     var x0 = xScale.invert(d3.mouse(this)[0] - margin.left);
		//     var i = bisectHour(data, x0, d3.min(data, function (d){ return d['Hour']; }));
		//     console.log("I: ", i);

		//     if (i <= d3.max(data, function (d){ return d['Hour']; }) && i>d3.min(data, function (d){ return d['Hour']; })){
		// 	    var d0 = data[i - 1];
		// 	    console.log(d0)
		// 	    var d1 = data[i],
		// 	        d = x0 - d0['Hour'] > d1['Hour'] - x0 ? d1 : d0;
		// 	    focus.attr("transform", "translate(" + (margin.left + xScale(d['Hour'])) + "," + (margin.top + yScale(d['Count'])) + ")");
		// 	    focus.select("text").text(d['Count']);
		// 	} else {
		// 		//console.log("CAUGHT EXCEPTION!");
		// 	}
		// }
	}
    function updateLineChart(data){

    	console.log("BEFORE SORTING!", data);

    	function compareHours(a, b){
    		if (a.Hour < b.Hour){ return -1; }
    		if (a.Hour > b.Hour){ return 1; }
    		return 0;
    	}

    	var data2 = data.sort(compareHours);
    	console.log("AFTER SORTING!", data2);

    	var hourLookup = d3.map();
    	if (data.length == lineData.length){
    		console.log("THIS IS WORKING!");
    	}
    	else {
    		console.log("THEY ARE DIFFERNET LENGTHS!");
    		console.log(data.length);
    	}
    	data.forEach(function(d, i){
    		hourLookup = hourLookup.set(d.Hour, i);
			d.Count = +d.Count;
		});
    	console.log(hourLookup);
    	var basics = scatterPlotBasics();
		var margin = basics.margin,
			w = basics.width,
		   	h = basics.height,
		   	circleRadius = basics.circleRadius
			;

      	//Inner SVG dimensions
      	var innerWidth  = w - margin.left - margin.right;
      	var innerHeight = h - margin.top  - margin.bottom;

      	var xScale = d3.scaleLinear().rangeRound([0, innerWidth]);
      	var yScale = d3.scaleLinear().rangeRound([innerHeight, 0]);

      	// //x and y axis
      	var xAxis = d3.axisBottom(xScale)
      					.tickFormat(d3.format("d"))
      					.ticks(data.length - 1);
      	var yAxis = d3.axisLeft(yScale);

        xScale.domain(d3.extent(data, function(d) { return d['Hour']; }));
        yScale.domain([0, d3.max(data, function (d){ return d['Count']; })]);
        console.log(data);
        //line
      	var line = d3.line()
		    .x(function(d) { return xScale(d['Hour']); })
		    .y(function(d) { return yScale(d['Count']); });
       
        var svg = d3.select("#plot1 svg").transition();

        svg.select("#linePath")
				.duration(750)
			    .attr("d", line(data));

        svg.select("#lineChartXAxis")
        		.duration(750)
        		.call(xAxis);

        svg.select("#lineChartYAxis")
        		.duration(750)
        		.call(yAxis);

		

		var focus = d3.select(".focus");
		d3.select(".overlay")
	      .on("mouseover", function() { focus.style("display", null); })
	      .on("mouseout", function() { focus.style("display", "none"); })
	      .on("mousemove", mousemove);
	    console.log(data);
		function mousemove() {
		    var x0 = xScale.invert(d3.mouse(this)[0] - margin.left);
		    if (x0 < d3.min(data, function (d){ return d['Hour']; })) {
		    	x0 = d3.min(data, function (d){ return d['Hour']; });
		    }
		    if (x0 > d3.max(data, function (d){ return d['Hour']; })) {
		    	x0 = d3.max(data, function (d){ return d['Hour']; });
		    }
		    var i = hourLookup.get(Math.round(x0));
		    if (i<=0){
		    	d = data[0];
		    } else {
			    var d0 = data[i - 1];
			    console.log(d0)
			    var d1 = data[i],
			        d = x0 - d0['Hour'] > d1['Hour'] - x0 ? d1 : d0;
			}
		    focus.attr("transform", "translate(" + (margin.left + xScale(d['Hour'])) + "," + (margin.top + yScale(d['Count'])) + ")");
		    focus.select("text").text(d['Count']);
			
		}


    }

      function update2(data){
		console.log("UPDATING CONNECTION TIME CHART NOW!");
		data.forEach(function(d){
			d.Count = +d.Count;
		});

		yScale2.domain([0, d3.max(data, function (d){ return d[yColumn2]; })]);
		xScale2.domain(data.map( function (d){ return d[xColumn2]; }));

		xAxisG2.call(xAxis2);
		yAxisG2.call(yAxis2);

		g2.selectAll("circle")
		   .data(data)
		   .transition()
		   .attr("cx", function (d){return xScale2(d[xColumn2]) + margin2.right - circleRadius; })
          .attr("cy", function (d){ return yScale2(d[yColumn2]); });

	}

	function inspectBuilding(data){

		console.log("Before updating");
		updateLineChart(data[0]['Time']);
		updatePathChart(data[0]['Paths']);
		console.log("After updating");
	}

	/* HEAT MAP */
	function heatMapBasics(){
		var coords = {lat1: 43.1451636, lat2: 43.1297806, long1: -70.940935, long2: -70.9262369},
			width = 600,
		   	height = 620,
			circleRadius = 5
			;
		
		return {
			coords : coords,
			width : width, 
			height : height,
			circleRadius : circleRadius,

		};	
	}

	function heatMap(data){

		function compareHours(a, b){
    		if (a.Building < b.Building){ return -1; }
    		if (a.Building > b.Building){ return 1; }
    		return 0;
    	}

    	var data = data.sort(compareHours);

		var basics = heatMapBasics();

		var coords = basics.coords,
			w = basics.width,
		   	h = basics.height,
		   	circleRadius = basics.circleRadius
			;

  		var circleScale = d3.scaleSqrt().range([3,12]);

  		var colorScale = d3.scaleOrdinal(d3.schemeCategory10);//.domain([]);

  		latitudeScale.domain([coords.lat1, coords.lat2]);
  		longitudeScale.domain([coords.long1, coords.long2]);

  		var svg = d3.select("#campussvg");

		var div = d3.select("body").append("div")
					.attr("id", "buildingTooltip")
				    .attr("class", "tooltip")
				    .style("opacity", 0);//d3.select('#tooltip');

        circleScale.domain([d3.min(data, function (d){ return d['Count']; }), d3.max(data, function (d){ return d['Count']; })]);

        

		var circles = svg.selectAll("circle")
			.data(data)
			.enter()
			.append('circle')
				.attr("class", "circle")
				.attr("id", function(d){ return d['Building'].replace(/\s/g, ""); })
		  		.attr("r", function(d){
		  			return circleScale(d['Count']);
		  		})
		  		.attr("cx", function(d) {
		  			console.log("NOT SUPPOSED TO BE HERE!");
		  			return longitudeScale(building_table.get(d['Building'])[0]) - 4;
		  		})
		  		.attr("cy", function(d){
		  			return latitudeScale(building_table.get(d['Building'])[1]) + 4;
		  		})
		  		.attr("fill", function(d){ return colorScale(building_table.get(d['Building'])[2]); })
		  		//.attr("data-legend",function(d) { return building_table.get(d['Building'])[2]})
		  		.on("mouseover", function(d){
		  			console.log(d['Building'], d['Count']);
		  			d3.select("#buildingTooltip").transition()
				         .duration(200)
				         .style("opacity", .9);
				    d3.select("#buildingTooltip").html(d['Building'] + "<br/>" + d['Count'])
				         .style("left", (d3.event.pageX - 50) + "px")
				         .style("top", (d3.event.pageY - 40) + "px");
		  		})
		  		.on("mouseout", function(d) {
			       d3.select("#buildingTooltip").transition()
			         .duration(500)
			         .style("opacity", 0); 
			     })
		  		.on("mousedown", function(d){
		  			console.log("PRESSED ME!");
		  			console.log(d);

		  			if(d3.select("#"+d['Building'].replace(/\s/g, "")).attr("class") == "selected"){
		  				d3.selectAll(".uncolor")
				   			.attr("class", "circle");
				   		d3.selectAll(".selected")
				   			.attr("class", "circle");
				   		selectedBuilding = "None";
				   		updateCharts(origData);
				   		//LOAD ORIGINAL DATA

			   		} else if(selectedBuilding != "None"){

			   			d3.selectAll(".uncolor")
				   			.attr("class", "circle");
				   		d3.selectAll(".selected")
				   			.attr("class", "circle");

				   		d3.json("/api/cache?Building="+d['Building'], inspectBuilding);
			  			selectedBuilding = d['Building'];
			  			d3.selectAll(".circle")
			   			.attr("class", "uncolor");

				   		console.log("#"+d['Building'].replace(/\s/g, ""));
				   		d3.select("#"+d['Building'].replace(/\s/g, ""))
				   			.attr("class", "selected");
			   			//DO STUFF
			   		}
			   		else {
				   		d3.json("/api/cache?Building="+d['Building'], inspectBuilding);
			  			selectedBuilding = d['Building'];
			  			d3.selectAll(".circle")
			   				.attr("class", "uncolor");

				   		console.log("#"+d['Building'].replace(/\s/g, ""));
				   		d3.select("#"+d['Building'].replace(/\s/g, ""))
				   			.attr("class", "selected");
			   		}
		  		});

		var legendCircleRadius = 5;
		var legendSpacing = 12;

		
		var legend = svg.append('rect')
						.attr('class', 'legend')
						.attr('x', w-130)
						.attr('y', '15');

		console.log("COLORSCALE!");
		console.log(colorScale.domain());

		var legendCircles = svg.selectAll('.legend')
		  .data(colorScale.domain(), function(d, i) { 
		  	console.log("ADJUSTED DATA:");
		  	console.log(d);
		  	console.log(i);
		  	return d + i; })
		  .enter()
		  .append('g')
		  .attr('class', 'legendCircle')
		  .attr('transform', function(d, i) {

		  	console.log("INSIDE TRANSFORM:");
		  	console.log(d);
		  	console.log(i);
		    var height = legendCircleRadius + legendSpacing;
		    var offset =  height * colorScale.domain().length / 2;
		    var vert = i * height - offset + 75;
		    return 'translate(' + (w-120) + ',' + vert + ')';
		  });

		legendCircles.append('circle')
		  .attr('r', legendCircleRadius)
		  .attr('class', 'legCircle')
		  .style('fill', colorScale)
		  .style('stroke', colorScale)
		  .on('mousedown', function(d){
		  	    console.log(d);
		  	    if(selectedBuilding == d){
		  	    	d3.selectAll(".uncolor")
				   		.attr("class", "circle");
			   		d3.selectAll(".selectedL")
			   			.attr("class", "legCircle");
			   		d3.selectAll(".uncolorL")
			   			.attr("class", "legCircle");
			   		// d3.selectAll(".legCircle")
			   		//  	.attr("opacity",.5);

			   	// 	d3.selectAll('.leg')
			   	// 		.attr("class", function(c){
			   	// 			console.log("in legCircle!");
			   	// 			console.log(c);
			   	// 			console.log(d);
			   	// 			if (c == d) {
			   	// 				console.log("HERE?");
							// 	return "legCircSelected";//'selected';
							// } else {
							// 	return "legCircUnselected";//'uncolor';
							// };
			   	// 		});

			   		selectedBuilding = "None";
			   		updateCharts(origData);
		  	    } else if(selectedBuilding != "None"){

		   			d3.selectAll(".uncolor")
			   			.attr("class", "circle");
			   		d3.selectAll(".selected")
			   			.attr("class", "circle");
			   		// d3.selectAll(".uncolorL")
			   		// 	.attr("class", "legCircle");
			   		// d3.selectAll(".selectedL")
			   		// 	.attr("class", "legCircle");

		   			// d3.selectAll(".uncolor")
			   		// 	.attr("class", "circle");
			   		// d3.selectAll(".selected")
			   		// 	.attr("class", "uncolor");
			   		// d3.selectAll(".selectedL")
			   		// 	.attr("class", "legCircle");
			   	// 	d3.selectAll('.legCircle')
			   	// 		.attr("opacity", function(c){
			   	// 			if (building_table.get(c['Building'])[2] == d) {
							// 	return 1.0;
							// } else {
							// 	return .3;
							// };
			   	// 		});

			   		d3.json("/api/cache?Type="+d, inspectBuilding);
		  			selectedBuilding = d;

		  			d3.selectAll('.selectedL')
			   			.attr("class", function(c){
			   				if (c == d) {
			   					console.log("HERE?");
								return 'selectedL';
							} else {
								return 'uncolorL';
							};
			   			});
			   		d3.selectAll('.uncolorL')
			   			.attr("class", function(c){
			   				if (c == d) {
			   					console.log("HERE?");
								return 'selectedL';
							} else {
								return 'uncolorL';
							};
			   			});
			   		d3.select("#campussvg")
						.selectAll(".circle")
						.attr("class", function(c){
					
							if (building_table.get(c['Building'])[2] == d) {
								return 'selected';
							} else {
								return 'uncolor';
							};
					});

		   		}
		   		else {
		   			d3.json("/api/cache?Type="+d, inspectBuilding);
		  			selectedBuilding = d;

		  			d3.select("#campussvg")
						.selectAll(".circle")
						.attr("class", function(c){
					
							if (building_table.get(c['Building'])[2] == d) {
								return 'selected';
							} else {
								return 'uncolor';
							};
					});

					d3.selectAll('.legCircle')
			   			.attr("class", function(c){
			   				if (c == d) {
			   					console.log("HERE?");
								return 'selectedL';
							} else {
								return 'uncolorL';
							};
			   			});
			   	// 	d3.json("/api/cache?Building="+d['Building'], inspectBuilding);
		  			// selectedBuilding = d['Building'];
		  			// d3.selectAll(".circle")
		   		// 		.attr("class", "uncolor");

			   	// 	console.log("#"+d['Building'].replace(/\s/g, ""));
			   	// 	d3.select("#"+d['Building'].replace(/\s/g, ""))
			   	// 		.attr("class", "selected");
		   		}
		  		// d3.selectAll(".circle")
			  //  				.attr("class", "uncolor");
			 //  if (selectedBuilding != "None"){
			 //  	d3.selectAll(".uncolor")
	   // 				.attr("class", "circle");
	   // 			d3.selectAll(".selected")
	   // 				.attr("class", "circle");
	   // 			selectedBuilding = "None";
			 //  }

			 //  d3.select("#campussvg")
				// .selectAll(".circle")
				// .attr("class", function(c){
					
				// 	if (building_table.get(c['Building'])[2] == d) {
				// 		return 'selected';
				// 	} else {
				// 		return 'uncolor';
				// 	}
				// });

		  	});

		legendCircles.append('text')
		  .attr('x', legendCircleRadius + legendSpacing - 5)
		  .attr('y', legendCircleRadius - 2 )//- legendSpacing)
		  .attr('font-size', '10')
		  .text(function(d) { return d; });

	}

	function updateHeatMap(data) {

		console.log("BEFORE SORTING!", data);

    	function compareHours(a, b){
    		if (a.Building < b.Building){ return -1; }
    		if (a.Building > b.Building){ return 1; }
    		return 0;
    	}

    	var data = data.sort(compareHours);
    	//console.log("AFTER SORTING!", data2);

		var basics = heatMapBasics();

		var coords = basics.coords,
			w = basics.width,
		   	h = basics.height,
		   	circleRadius = basics.circleRadius
			;

  		var circleScale = d3.scaleSqrt().range([3,12]);

  		var colorScale = d3.scaleOrdinal(d3.schemeCategory10);//.domain([]);

  		latitudeScale.domain([coords.lat1, coords.lat2]);
  		longitudeScale.domain([coords.long1, coords.long2]);

  // 		var svg = d3.select("#campussvg");

        circleScale.domain([d3.min(data, function (d){ return d['Count']; }), d3.max(data, function (d){ return d['Count']; })]);

        var svg = d3.select("#campussvg");
        console.log(data);

		var circles = svg.selectAll(".circle")
			.data(data)
			//.enter()
			//.append('circle')
			//.attr("class", "circle")
			//.transition()
			//.duration(500)
	  		.attr("r", function(d){
	  			return circleScale(d['Count']);
	  		})
	  		.attr("cx", function(d) {
	  			console.log(d["Building"])
	  			return longitudeScale(building_table.get(d['Building'])[0]) - 4;
	  		})
	  		.attr("cy", function(d){
	  			return latitudeScale(building_table.get(d['Building'])[1]) + 4;
	  		})
	  		// .attr("fill", function(d){ return colorScale(building_table.get(d['Building'])[2]); })
	  		//.attr("data-legend",function(d) { return building_table.get(d['Building'])[2]})
	  		.on("mouseover", function(d){
	  			console.log(d['Building'], d['Count']);
	  			var div = d3.select("#buildingTooltip");
	  			div.transition()
			         .duration(200)
			         .style("opacity", .9);
			       div.html(d['Building'] + "<br/>" + d['Count'])
			         .style("left", (d3.event.pageX - 50) + "px")
			         .style("top", (d3.event.pageY - 40) + "px");
	  		})
	  		.on("mouseout", function(d) {
	  			var div = d3.select("#buildingTooltip");
		        div.transition()
		         .duration(500)
		         .style("opacity", 0); 
		     })
	  		.on("mousedown", function(d){
		  			console.log("PRESSED UPDATED ME!");
		  			console.log(d);
		  			if(d3.select("#"+d['Building'].replace(/\s/g, "")).attr("class") == "selected"){
		  				d3.selectAll(".uncolor")
				   			.attr("class", "circle");
				   		d3.selectAll(".selected")
				   			.attr("class", "circle");
				   		selectedBuilding = "None";
				   		updateCharts(origData);
				   		//LOAD ORIGINAL DATA

			   		} else if(selectedBuilding != "None"){

			   			d3.selectAll(".uncolor")
				   			.attr("class", "circle");
				   		d3.selectAll(".selected")
				   			.attr("class", "circle");

				   		d3.json("/api/cache?Building="+d['Building'], inspectBuilding);
			  			selectedBuilding = d['Building'];
			  			d3.selectAll(".circle")
			   			.attr("class", "uncolor");

				   		console.log("#"+d['Building'].replace(/\s/g, ""));
				   		d3.select("#"+d['Building'].replace(/\s/g, ""))
				   			.attr("class", "selected");
			   			//DO STUFF
			   		}
			   		else {
				   		d3.json("/api/cache?Building="+d['Building'], inspectBuilding);
			  			selectedBuilding = d['Building'];
			  			d3.selectAll(".circle")
			   			.attr("class", "uncolor");

				   		console.log("#"+d['Building'].replace(/\s/g, ""));
				   		d3.select("#"+d['Building'].replace(/\s/g, ""))
				   			.attr("class", "selected");
			   		}
		  	});
	  	var circles = svg.selectAll(".circle")
			.transition()
			.duration(500);
	  	// svg.transition();

    //     svg.selectAll('.circle').duration(300)
		  // 	.attr("r", function(d) { return circleScale(d['count']);})
		  // 	.attr("opacity",1);


	}
   

    </script>

</body>

</html>